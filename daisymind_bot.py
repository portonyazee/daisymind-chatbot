# -*- coding: utf-8 -*-
"""daisymind_bot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16rcRiOTM5jyVNx2GzC73R4sSNUR3Oc0e
"""

!pip install python-telegram-bot==13.15 xgboost joblib scikit-learn

!pip install xgboost joblib scikit-learn

pip install urllib3

!pip uninstall -y python-telegram-bot telegram
!pip install python-telegram-bot==20.7 --upgrade

import telegram
print(telegram.__version__)

import pandas as pd
import joblib
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics import classification_report, accuracy_score
from xgboost import XGBClassifier

# === Load dataset ===
df = pd.read_csv("dreaddit-train.csv")

# Kolom penting
#   - text  : teks curhatan
#   - label : 0 = non-stress, 1 = stress
df = df.dropna(subset=["text", "label"]).copy()
df["text"] = df["text"].astype(str)
df["label"] = df["label"].astype(int)

# (Opsional) subsample biar training cepat (tetap stratified)
max_per_class = 600
df_trainable = (
    df.groupby("label", group_keys=False)
      .apply(lambda g: g.sample(n=min(len(g), max_per_class), random_state=42))
      .reset_index(drop=True)
)

# === Vectorize TF-IDF ===
tfidf = TfidfVectorizer(
    max_features=2000,      # aman & cepat; boleh dinaikkan kalau GPU/CPU kuat
    ngram_range=(1,2),      # unigram+bigram sering bantu performa teks
    stop_words="english"
)
X = tfidf.fit_transform(df_trainable["text"])
y = df_trainable["label"]

# === Split ===
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

# === Train XGBoost ===
model = XGBClassifier(
    n_estimators=200,
    max_depth=5,
    learning_rate=0.1,
    subsample=0.9,
    colsample_bytree=0.9,
    objective="binary:logistic",
    eval_metric="logloss",
    n_jobs=2,
    random_state=42
)
model.fit(X_train, y_train)

# === Evaluasi ringkas ===
y_proba = model.predict_proba(X_test)[:, 1]
y_pred = (y_proba >= 0.5).astype(int)

print("Akurasi:", round(accuracy_score(y_test, y_pred), 4))
print(classification_report(y_test, y_pred, digits=4))

# === Simpan artefak untuk bot ===
joblib.dump(model, "stress_xgb.pkl")
joblib.dump(tfidf, "tfidf_vectorizer.pkl")
print("âœ… Saved: stress_xgb.pkl & tfidf_vectorizer.pkl")

import pandas as pd
import joblib

# Load model dan vectorizer
model = joblib.load("stress_xgb.pkl")
tfidf = joblib.load("tfidf_vectorizer.pkl")

# Load dataset (contoh: dreaddit-train.csv)
df = pd.read_csv("dreaddit-train.csv")

# Asumsi kolom teks bernama 'text' dan label 'label' (0=tidak stress, 1=stress)
sample_stress_texts = df["text"].astype(str).tolist()

# Vectorize
X_infer = tfidf.transform(sample_stress_texts)

# Prediksi
proba = model.predict_proba(X_infer)[:,1]
preds = (proba >= 0.5).astype(int)

# Gabungkan hasil ke dataframe
df["predicted_label"] = preds
df["probability"] = proba

# Print contoh 10 data
for t, p, pr in zip(sample_stress_texts[:10], preds[:10], proba[:10]):
    label = "STRESS" if p==1 else "Tidak Stress"
    print(f"{label} (p={pr:.2f})  ::  {t}")

# Simpan hasil lengkap ribuan kalimat
df.to_csv("predicted_dataset.csv", index=False)

import os
import joblib
import random
import nest_asyncio, asyncio
import pandas as pd
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes,
    filters, CallbackQueryHandler
)

# ====== TOKEN ======
BOT_TOKEN = os.environ.get("BOT_TOKEN", "").strip()
if not BOT_TOKEN:
    BOT_TOKEN = "8498636410:AAFbfKL35TgyxGflWn_wix4-RU59D4hHa00"  # <-- ganti tokenmu di sini

# ====== Load model ======
model = joblib.load("stress_xgb.pkl")
tfidf = joblib.load("tfidf_vectorizer.pkl")

def predict_text(text: str):
    X = tfidf.transform([text])
    p = float(model.predict_proba(X)[:, 1][0])
    y = int(p >= 0.5)
    return y, p

# ====== SIMPLE STATE ======
user_states = {}      # per-user simple state
user_logs = []        # global logs (you may wish to persist per-user logs in DB)

# ====== Welcome text ======
def _welcome_markdown_text() -> str:
    return (
        "Heyy ğŸ‘‹ I'm **Zee** â€” kinda like your chill buddy who checks in on your vibes âœ¨\n\n"
        "Just drop me whateverâ€™s on your mind, and Iâ€™ll tell you if it sounds *Stress* or *Not Stress*.\n\n"
        "ğŸ’¡ And donâ€™t worry, I got you anytime, anywhere ğŸ¤"
    )

async def _send_welcome(context: ContextTypes.DEFAULT_TYPE, chat_id: int):
    await context.bot.send_message(chat_id=chat_id, text=_welcome_markdown_text(), parse_mode="Markdown")

# ====== SMART REPLY SYSTEM ======
def smart_reply(user_text: str, y: int, p: float):
    text = user_text.lower()

    # Questions
    if "?" in text:
        if "chocolate" in text:
            return "ğŸ« Honestly, chocolate lowkey helps stress! Dark ones hit different."
        elif "sleep" in text:
            return "ğŸ˜´ Sleep is top tier self-care. Wanna hear quick tips to snooze better?"
        else:
            return random.choice([
                "Ooo good question ğŸ¤” what do *you* think?",
                "Hmm interesting ğŸŒ¿ tell me your take on it!",
                "Thatâ€™s a solid one âœ¨ how do you feel about it tho?"
            ])

    # Food / drink
    if any(word in text for word in ["eat", "food", "drink", "makan", "minum"]):
        return random.choice([
            "Food defs affects mood ğŸŒ± whatâ€™s your go-to comfort snack?",
            "Yum ğŸ² eating good = feeling good. Whatâ€™s your fave food rn?",
            "Comfort food always hits âœ¨ what meal cheers you up the most?"
        ])

    # Emotions
    if any(word in text for word in ["sad", "sedih", "tired", "capek", "marah", "angry"]):
        return random.choice([
            "That sounds heavy ğŸ¤ wanna vent more? Iâ€™m here.",
            "Totally okay to feel like that ğŸŒ¿ youâ€™re not alone, trust.",
            "Big hug incoming ğŸ¤— you deserve all the softness today."
        ])
    if any(word in text for word in ["happy", "senang", "bahagia", "excited"]):
        return random.choice([
            "Yay love that âœ¨ whatâ€™s making you smile rn?",
            "Your energy is contagious ğŸŒ¸ keep glowing!",
            "So glad youâ€™re vibinâ€™ ğŸ¤ lock that feeling in."
        ])

    # Activity
    if any(word in text for word in ["work", "kerja", "study", "belajar", "school", "kampus"]):
        return random.choice([
            "Work/study grind is real ğŸŒ± remember breaks exist ğŸ‘€",
            "Youâ€™re hustling hard ğŸ¤ proud of you fr.",
            "Balance vibes âœ¨ donâ€™t forget rest in between."
        ])
    if any(word in text for word in ["sleep", "tidur", "rest", "istirahat"]):
        return random.choice([
            "Rest = ultimate glow up ğŸŒ¿ your body & brain need it.",
            "Sleep can literally reset your whole vibe âœ¨ you sleeping well?",
            "Donâ€™t sleep onâ€¦ sleep ğŸ¤ itâ€™s as valid as hard work."
        ])

    # Relationships
    if any(word in text for word in ["friend", "teman", "sahabat", "family", "keluarga", "mama", "papa"]):
        return random.choice([
            "People you vibe with = priceless ğŸ¤ howâ€™s your circle rn?",
            "Family/friends give so much comfort ğŸŒ¿",
            "Itâ€™s wholesome sharing life with ppl you love ğŸ’«"
        ])

    # Default based on stress detection
    if y == 1:  # Stress
        if p > 0.8:
            return random.choice([
                "Thatâ€™s a lot to carry ğŸ¤ wanna share what hit hardest today?",
                "I feel you ğŸŒ¿ sounds overwhelming tbh.",
                "Youâ€™re holding smth heavy rnâ€¦ Iâ€™m here for you ğŸ’«"
            ])
        else:
            return random.choice([
                "Catching some stress vibes ğŸŒ± whatâ€™s one tiny thing that might help rn?",
                "You might be a lil tense ğŸ¤ deep breath time?",
                "Even small stress counts ğŸŒ¿ how do you usually cope?"
            ])
    else:  # Not stress
        if p < 0.2:
            return random.choice([
                "Peaceful energy âœ¨ whatâ€™s keeping you this relaxed?",
                "Your calmness is goals ğŸŒ¿ keep enjoying it.",
                "Love that peace ğŸ¤ soak it all in."
            ])
        else:
            return random.choice([
                "Youâ€™re vibin okay ğŸŒ¿ found anything cool to unwind with lately?",
                "Sounds pretty balanced âœ¨ what keeps you steady?",
                "Handling it well ğŸ¤ keep doing you!"
            ])

# ====== Handlers ======
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_states.clear()
    await _send_welcome(context, update.effective_chat.id)

async def help_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Just type how youâ€™re feeling ğŸŒ¿\nIâ€™ll always be around to listen ğŸ¤"
    )

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    user_text = (update.message.text or "").strip()

    if not user_text:
        await update.message.reply_text("Drop some text first ğŸŒ¸")
        return

    y, p = predict_text(user_text)
    label = "âš ï¸ Detection Stress" if y == 1 else "âœ… Not Stress"
    tips = smart_reply(user_text, y, p)

    reply = f"{label}\nConfidence: {p:.2f}\n\n{tips}\n\nğŸ’¡ I gotchu anytime, anywhere ğŸ¤"

    keyboard = [
        [
            InlineKeyboardButton("ğŸŒ¸ Keep Talking", callback_data="continue"),
            InlineKeyboardButton("ğŸ¤ End Chat", callback_data="end")
        ]
    ]

    if y == 1:
        keyboard.append([
            InlineKeyboardButton("ğŸ§˜ Breathe", callback_data="relax_breathing"),
            InlineKeyboardButton("ğŸ¶ Chill Playlist", callback_data="relax_playlist"),
            InlineKeyboardButton("ğŸ““ Journal Prompt", callback_data="relax_journaling"),
        ])
    else:
        keyboard.append([
            InlineKeyboardButton("ğŸµ Hype Playlist", callback_data="relax_upbeat"),
            InlineKeyboardButton("ğŸ® Tiny Game", callback_data="relax_game"),
            InlineKeyboardButton("ğŸ™ Gratitude Check", callback_data="relax_gratitude"),
        ])

    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(reply, reply_markup=reply_markup)

    user_states[user_id] = {"last_label": label, "last_prob": p, "last_text": user_text}
    user_logs.append({
        "user_id": user_id,
        "text": user_text,
        "predicted_label": label,
        "probability": p
    })
    pd.DataFrame(user_logs).to_csv("mood_logs.csv", index=False)

# ====== Callback for buttons ======
async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data == "continue":
        await query.message.reply_text("ğŸŒ¸ Bet, keep going â€” Iâ€™m listening ğŸ¤")
        return

    if query.data == "end":
        farewell_quotes = [
            "ğŸ¤ Thx for chatting ğŸŒ¸ remember, Iâ€™m always just one text away ğŸŒ¿",
            "âœ¨ Deep breath, you did enough today. Go rest ğŸ¤",
            "ğŸŒ± Even if itâ€™s tough rn, better days are coming. Iâ€™ll be waiting ğŸ¤"
        ]
        await query.message.reply_text(random.choice(farewell_quotes))
        await query.message.reply_text("ğŸ¤— Big hug your way!")

        keyboard = [[InlineKeyboardButton("ğŸ”„ Restart Chat", callback_data="restart")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.message.reply_text("Wanna start fresh?", reply_markup=reply_markup)
        return

    if query.data == "restart":
        uid = query.from_user.id
        if uid in user_states:
            del user_states[uid]
        global user_logs
        user_logs = [log for log in user_logs if log.get("user_id") != uid]
        pd.DataFrame(user_logs).to_csv("mood_logs.csv", index=False)

        await query.message.reply_text("ğŸ”„ Fresh start! Letâ€™s vibe again ğŸŒ¸")
        await _send_welcome(context, query.message.chat_id)
        return

    # Quick Relax Tips
    if query.data == "relax_breathing":
        await query.message.reply_text("ğŸ§˜ Try this: Inhale 4s, hold 4s, exhale 6s. Repeat 5x ğŸŒ¿")
        return
    if query.data == "relax_playlist":
        await query.message.reply_text("ğŸ¶ Chill playlist for u: https://open.spotify.com/playlist/37i9dQZF1DX3rxVfibe1L0")
        return
    if query.data == "relax_journaling":
        await query.message.reply_text("ğŸ““ Journal idea: Write 3 things youâ€™re grateful for + 1 thing youâ€™re letting go âœ¨")
        return
    if query.data == "relax_upbeat":
        await query.message.reply_text("ğŸµ Hype playlist to boost ur mood: https://open.spotify.com/playlist/37i9dQZF1DX1g0iEXLFycr")
        return
    if query.data == "relax_game":
        riddle = "ğŸ§© Riddle time: I speak without a mouth and hear without ears. I have nobody, but I come alive with wind. What am I?"
        await query.message.reply_text(riddle)
        return
    if query.data == "relax_gratitude":
        await query.message.reply_text("ğŸ™ Gratitude check: name 3 small wins today â€” even tiny ones count!")
        return

# ====== Run polling ======
async def main():
    app = ApplicationBuilder().token(BOT_TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_cmd))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    app.add_handler(CallbackQueryHandler(button_handler))

    print("ğŸ¤– Zee bot (gen z edition) is running...")
    await app.run_polling()

nest_asyncio.apply()
await asyncio.sleep(0)
await main()